#ifndef RANSAC
#define RANSAC

#include <iostream>
#include <string>
#include <tuple>

#include <opencv2/opencv.hpp>
#include "../data_containers/Frame/frame.hpp"
//#include features descriptor from nicolas ORB

class Ransac{
  //
  //ransac is going to be applied on pair of KeyPoints matched by ORB
  //
  public :
    float w_goal = 0;// goal inlier rate
    uint64_t n = 0; // nb samples necessary ton create a model
    uint64_t nb_samples = 0 ;
    float max_error = 0; // maximum accepted error for a point to be defined as an inlier unit = ?
    cv::Affine3 <float> P ; // rotation matrix from cam d to cam g defined at the beginning
    cv::Matx33f K_l ;
    cv::Matx33f K_r ;

    float best_w = 0;
    cv::Affine3<float> best_transform ; // tranform matrix generated by best_points
    std::vector<std::tuple<cv::KeyPoint, cv::KeyPoint, cv::DMatch> >  best_points ; //point who created the transformation matrix that got the most inliers

    std::vector< std::tuple< cv::KeyPoint , cv::KeyPoint , cv::DMatch > > inlier ; // data points whose reprojection error is under max_eror value
    std::tuple< std::vector<cv::KeyPoint> , std::vector<cv::KeyPoint> , std::vector<cv::DMatch> , bool > data ; //every data points given to ransac for analysis

    //ordered map of paired points  points can be either 3D or 2D points with a feature map
    Ransac(std::tuple< std::vector<cv::KeyPoint> , std::vector<cv::KeyPoint> , std::vector<cv::DMatch> , bool > datapoint , uint64_t n , float error , float w , cv::Matx33f R, cv::Matx31f T , cv::Matx33f K_g , cv::Matx33f K_d );
    ~Ransac(void);

    //whole process of applying ransac on the dataset until we found reliable points
    cv::Affine3<float> apply_ransac(); //USELESS BC on a deja la matrice de transformation de la camera gauche à la caméra droite et elle est quasi constante

    //application of the transformation in order to get the inlier
    //returns the number of inlier found
    int check_inliers(cv::Affine3<float> P);

    //create a transform matrix based on a array of n pair of points
    cv::Affine3<float> transform_from_KeyPoints(std::vector<std::tuple<cv::KeyPoint, cv::KeyPoint, cv::DMatch> > kp); //Inutile pour la raison qu'on a pas besoin de creer la matrice de tarnsformation

    // reset need values in order to avoid having to destroy and rebuild an object
    void reset();

    //apply transform on a given point
    cv::Mat apply_transform(cv::Mat);

    //extract n different and random cv::KeyPoints from the data to process the data
    std::vector <std::tuple< cv::KeyPoint , cv::KeyPoint , cv::DMatch > > get_n_KeyPoints();

    //Allow an easy access of data in form of pairs
    std::tuple< cv::KeyPoint , cv::KeyPoint , cv::DMatch > operator[](uint64_t index);


    protected :

    private :

};

//to string
std::ostream& operator<< (std::ostream& os , Ransac r);



#endif
